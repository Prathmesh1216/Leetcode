class Solution {
public:
    vector<int> parent,rank;
    int findPar(int node){
        if(parent[node]==node) return node;
        return parent[node] = findPar(parent[node]);
    }
    void unionbr(int u,int v){
        u = findPar(u);
        v = findPar(v);
        if(rank[u]<rank[v]){
            parent[u] = v;
        }
        else if(rank[v]<rank[u]){
            parent[v] = u;
        }
        else{
            parent[u] = v;
            rank[v]++;
        }
    }
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<int> adj[n];
        parent.resize(n);
        rank.resize(n);
        for(int i = 0;i<n;i++) parent[i] = i;
        for(int i = 0;i<n;i++){
            for(int j = 0;j<n;j++){
                if(i!=j && graph[i][j]==1){
                    adj[i].push_back(j);
                    unionbr(i,j);
                }
            }
        }
        for(int i = 0;i<n;i++){
            parent[i] = findPar(i);
        }
        unordered_map<int,int> mp;
        for(int i = 0;i<initial.size();i++){
            mp[parent[initial[i]]]++;
        }
        unordered_map<int,int> mp1;
        for(auto it : parent) mp1[it]++;
        int ans = -1;
        int av = 0;
        for(int i = 0;i<initial.size();i++){
            if(mp[parent[initial[i]]]==1){
                if(av<mp1[parent[initial[i]]]){
                    ans = initial[i];
                    av = mp1[parent[initial[i]]];
                }
                else if(av==mp1[parent[initial[i]]]) ans = min(ans,initial[i]);
            }
        }
        if(ans==-1) return *min_element(initial.begin(),initial.end());
        return ans;

    }
};